plugins {
    id 'java-library'
    id 'eclipse'
    alias libs.plugins.license
    alias libs.plugins.gradleutils
    alias libs.plugins.versions
    alias libs.plugins.modules
}

repositories {
    mavenCentral()
    maven gradleutils.forgeMaven
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(16)
}

license {
    header = rootProject.file("LICENSE-header.txt")
}

test {
    useJUnitPlatform()
    reports.html.destination = rootProject.file("build/reports/")
    reports.junitXml.destination = rootProject.file("build/test-results/")
}

dependencies {
    testImplementation(rootProject)
    testImplementation(projects.modlauncherHarness)
    testImplementation(projects.mlTestJar)

    testImplementation(libs.junit.api)
    testImplementation(libs.unsafe)
    testImplementation(libs.securemodules)
    testImplementation(libs.jopt.simple)
    testImplementation(libs.bundles.log4j.runtime)

    testCompileOnly(libs.nulls)
    testRuntimeOnly(libs.bundles.junit.runtime)
}

extraJavaModuleInfo {
    failOnMissingModuleInfo = false
    automaticModule('net.sf.jopt-simple:jopt-simple', 'jopt.simple')
}

// If we are being told a specific vendor then we are probably being run in parallel
if (project.hasProperty('javaVendor') && project.hasProperty('javaVersion')) {
    test.javaLauncher.set(javaToolchains.launcherFor {
        it.vendor.set(JvmVendorSpec."${project.property('javaVendor').toUpperCase(Locale.ROOT)}" as JvmVendorSpec)
        it.languageVersion.set(JavaLanguageVersion.of(project.property('javaVersion') as int))
        it.implementation.set(JvmImplementation.VENDOR_SPECIFIC)
    })
} else if (!project.hasProperty('disable_bulk_tests')) {
    configurations {
        groovyScript
    }

    dependencies {
        groovyScript 'org.apache.ivy:ivy:2.4.0'
        groovyScript 'org.codehaus.groovy:groovy-all:3.0.19'
    }

    tasks.register('collectTests', JavaExec) {
        classpath = configurations.groovyScript
        main = 'groovy.ui.GroovyMain'
        args '.github/workflows/aggregate-junit-tests.groovy'
        workingDir rootProject.projectDir
    }

    VALID_VMS.each { javaVendor, javaVersions ->
        javaVersions.each { javaVersion ->
            def task = tasks.register("test${javaVendor}${javaVersion}", Test) {
                useJUnitPlatform()
                javaLauncher.set(javaToolchains.launcherFor {
                    it.vendor.set(JvmVendorSpec."${javaVendor.toUpperCase(Locale.ROOT)}" as JvmVendorSpec)
                    it.languageVersion.set(JavaLanguageVersion.of(javaVersion))
                    it.implementation.set(JvmImplementation.VENDOR_SPECIFIC)
                })
                reports.html.destination = rootProject.file("build/test_artifacts/test-reports-${javaVendor}-${javaVersion}/")
                reports.junitXml.destination = rootProject.file("build/test_artifacts/test-results-${javaVendor}-${javaVersion}/")
            }
            test.dependsOn(task)
            collectTests.mustRunAfter(task)
        }
    }
}

// Hack eclipse into knowing that the gradle deps are modules
eclipse.classpath {
    containers 'org.eclipse.buildship.core.gradleclasspathcontainer'
    file.whenMerged { entries.findAll { it.kind == 'lib' || it.path == 'org.eclipse.buildship.core.gradleclasspathcontainer' }.each { it.entryAttributes['module'] = 'true' } }
}

// Merge the resources and classes into the same directory.
// This is done because java expects modules to be in a single directory.
// And if we have it in multiple we have to do performance intensive hacks like having the UnionFileSystem
sourceSets.each {
    def dir = layout.buildDirectory.dir("sourcesSets/$it.name")
    it.output.resourcesDir = dir
    it.java.destinationDirectory = dir
}