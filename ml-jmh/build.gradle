plugins {
    id 'eclipse'
    id 'java-library'
    alias libs.plugins.apt
    alias libs.plugins.license
    alias libs.plugins.gradleutils
    alias libs.plugins.versions
    alias libs.plugins.modules
}

repositories {
    mavenCentral()
    maven gradleutils.forgeMaven
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(16)
}

license {
    header = rootProject.file("LICENSE-header.txt")
}

dependencies {
    implementation(rootProject)
    implementation(libs.securemodules)
    implementation(libs.unsafe)
    implementation(projects.mlTestJar)
    implementation(libs.jmh.core)
    implementation(libs.jopt.simple)
    runtimeOnly(libs.jmh.ap)

    annotationProcessor(libs.jmh.ap)
}

extraJavaModuleInfo {
    failOnMissingModuleInfo = false
    automaticModule('org.openjdk.jmh:jmh-core', 'org.openjdk.jmh') // They havent had a release in years -.-  https://github.com/openjdk/jmh/commit/a1ca901e8910d1206c4a957719b6e98fa3c67a61
    automaticModule('net.sf.jopt-simple:jopt-simple', 'jopt.simple')
}

def jmhArgs = [
    '-bm', 'AverageTime',  // Benchmark mode. Available modes are: [Throughput, AverageTime, SampleTime, SingleShotTime, All]
    '-r',  '3s',  // Minimum iteration time
    '-w',  '3s',  // Minimum warmup time
    '-wi', '3',   // Warmup iterations
    '-i',  '3',   // Iterations
    '-tu', 'us',  // Time unit: [m, s, ms, us, ns]
    '-f',  '3',   // Forks per benchmark
    '-rf', 'json', // Results File Format
    '-prof', 'stack', // Profiler: Simple and naive Java stack profiler
    '-prof', 'jfr',   // Profiler: Java Flight Recorder profiler
]

tasks.register('jmh', JavaExec) {
    dependsOn(rootProject.build)
    dependsOn(build)
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'org.openjdk.jmh.Main'
    args jmhArgs + ['-rff', rootProject.file('build/jmh_results.json')]

    if (project.hasProperty('javaVendor') && project.hasProperty('javaVersion')) {
        javaLauncher.set(javaToolchains.launcherFor {
            it.vendor.set(JvmVendorSpec."${project.property('javaVendor').toUpperCase(Locale.ROOT)}" as JvmVendorSpec)
            it.languageVersion.set(JavaLanguageVersion.of(project.property('javaVersion') as int))
            it.implementation.set(JvmImplementation.VENDOR_SPECIFIC)
        })
    } else {
        javaLauncher.set(javaToolchains.launcherFor(java.toolchain))
    }
}

// JMH's are expensive to run all variants, so only run if asked to
if (project.hasProperty('local_jmh')) {
    configurations {
        groovyScript
    }

    dependencies {
        groovyScript 'org.apache.ivy:ivy:2.4.0'
        groovyScript 'org.codehaus.groovy:groovy-all:3.0.19'
    }

    tasks.register('jmhAll', JavaExec) {
        classpath = configurations.groovyScript
        main = 'groovy.ui.GroovyMain'
        args '.github/workflows/aggregate-jmh-results.groovy'
        workingDir rootProject.projectDir
    }

    VALID_VMS.each { javaVendor, javaVersions ->
        javaVersions.each { javaVersion ->
            def task = tasks.register("jmh${javaVendor}${javaVersion}", JavaExec) {
                def output = rootProject.file("build/jmh_results/jmh-${javaVendor}${javaVersion}/jmh_results.json")
                dependsOn(rootProject.build)
                dependsOn(build)
                classpath = sourceSets.main.runtimeClasspath
                mainClass = 'org.openjdk.jmh.Main'
                args jmhArgs + [
                    '-v', 'SILENT', // Verbosity [SILENT, NORMAL, EXTRA]
                    '-rff', output
                ]
                doFirst { output.parentFile.mkdirs() }
                javaLauncher.set(javaToolchains.launcherFor {
                    it.vendor.set(JvmVendorSpec."${javaVendor.toUpperCase(Locale.ROOT)}" as JvmVendorSpec)
                    it.languageVersion.set(JavaLanguageVersion.of(javaVersion))
                    it.implementation.set(JvmImplementation.VENDOR_SPECIFIC)
                })
            }
            jmhAll.dependsOn(task)
        }
    }
}

// Hack eclipse to add the annotation processors in TODO: Upstream this to com.diffplug.eclipse.apt ?
eclipse {
    synchronizationTasks(eclipseFactorypath, eclipseJdt, eclipseJdtApt)
    classpath {
        file.beforeMerged {
            file('.apt_generated').mkdirs()
            def generated = new org.gradle.plugins.ide.eclipse.model.SourceFolder('.apt_generated', 'bin/.apt_generated')
            generated.entryAttributes['ignore_optional_problems'] = true
            entries << generated
        }
    }
}

// Hack eclipse into knowing that the gradle deps are modules
eclipse.classpath {
    containers 'org.eclipse.buildship.core.gradleclasspathcontainer'
    file.whenMerged { entries.findAll { it.kind == 'lib' || it.path == 'org.eclipse.buildship.core.gradleclasspathcontainer' }.each { it.entryAttributes['module'] = 'true' } }
}
